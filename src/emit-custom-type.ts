import * as path from 'path';
import { CodeMaker } from 'codemaker';
import * as srcmak from 'jsii-srcmak';
// we just need the types from json-schema
// eslint-disable-next-line import/no-extraneous-dependencies
import { JSONSchema4 } from 'json-schema';
import { TypeGenerator, TypeGeneratorOptions } from 'json2jsii';

/**
 * Emit imports for generated helm construct
 * @param code CodeMaker istance
 */
export function emitHelmHeader(code: CodeMaker) {
  code.line('// generated by cdk8s');
  code.line("import { Helm } from 'cdk8s';");
  code.line("import { Construct } from 'constructs';");
  code.line();
}

/**
 * Helm Object Definition
 */
export interface HelmObjectDefinition {
  /**
   * `values.schema.json` for the helm chart
   */
  readonly schema: JSONSchema4 | undefined;
  /**
   * Chart name
   */
  readonly chartName: string;
  /**
   * Chart url
   */
  readonly chartUrl: string;
  /**
   * Chart version
   */
  readonly chartVersion: string;
  /**
   * Chart dependencies
   */
  readonly chartDependencies: string[];
  /**
   * Fully qualified name for the construct
   */
  readonly fqn?: string;
}

export function generateHelmConstruct(
  typegen: TypeGenerator,
  def: HelmObjectDefinition,
) {
  const chartName = TypeGenerator.normalizeTypeName(def.chartName);
  const schema = def.schema;
  const repoUrl = def.chartUrl;
  const chartVersion = def.chartVersion;

  // Create custom type
  typegen.emitCustomType(chartName, (code) => {
    const valuesInterface = `${chartName}ValuesProps`;
    if (schema !== undefined) {
      // Interface for schema generated props
      let schemaGenValuesInterface: string = 'SchemaGeneratedValues';
      schemaGenValuesInterface = typegen.emitType(
        schemaGenValuesInterface,
        schema,
        def.fqn,
      );

      // Creating values interface
      emitValuesInterface();

      function emitValuesInterface() {
        code.openBlock(
          `export interface ${valuesInterface} extends ${schemaGenValuesInterface}`,
        );

        // Sub charts or dependencies
        for (const dependency of def.chartDependencies) {
          code.line(`readonly ${dependency}?: { [key: string]: any };`);
        }

        // Global values
        code.line('readonly global?: { [key: string]: any };');

        code.closeBlock();
      }
    }

    // Creating construct properties
    emitPropsInterface();

    code.line();

    // Creating construct for helm chart
    emitConstruct();

    function emitPropsInterface() {
      code.openBlock(`export interface ${chartName}Props`);

      code.line('readonly namespace?: string;');
      code.line('readonly releaseName?: string;');
      code.line('readonly helmExecutable?: string;');
      code.line('readonly helmFlags?: string[];');

      if (schema === undefined) {
        code.line('readonly values?: { [key: string]: any };');
      } else {
        code.line(`readonly values?: ${valuesInterface};`);
      }

      code.closeBlock();
    }

    function emitConstruct() {
      code.openBlock(`export class ${chartName} extends Helm`);

      emitInitializer();

      code.closeBlock();
    }

    function emitInitializer() {
      code.openBlock(
        `public constructor(scope: Construct, id: string, props: ${chartName}Props = {})`,
      );

      code.open('const finalProps = {');
      code.line(`chart: \'${def.chartName}\',`);
      code.line(`repo: \'${repoUrl}\',`);
      code.line(`version: \'${chartVersion}\',`);
      code.line('...props,');
      code.close('};');

      code.open('super(scope, id, {');
      code.line('...finalProps,');
      code.close('});');

      code.closeBlock();
    }
  });
}

export async function convertToOtherLanguages(
  fileName: string,
  filePath: string,
) {
  const deps = ['@types/node', 'constructs', 'cdk8s'];
  const testing = 'testing';

  const opts: srcmak.Options = {
    entrypoint: fileName,
    moduleKey: testing,
    deps: deps.map((dep) =>
      path.dirname(require.resolve(`${dep}/package.json`)),
    ),
  };

  // python!

  const moduleName = testing.replace(/-/g, '_');
  opts.python = {
    outdir: filePath,
    moduleName,
  };

  await srcmak.srcmak(filePath, opts);
}

export async function run(
  filePath: string,
  schema: JSONSchema4,
  chartName: string,
  chartUrl: string,
  chartVersion: string,
) {
  const code = new CodeMaker();
  console.log(`FILE PATH: ${filePath}`);
  const filename = 'test.ts';

  code.openFile(filename);
  code.indentation = 2;

  const options: TypeGeneratorOptions = {
    definitions: schema.definitions,
  };
  const typegen = new TypeGenerator(options);

  emitHelmHeader(code);

  const def: HelmObjectDefinition = {
    schema: schema,
    chartName: chartName,
    chartUrl: chartUrl,
    chartVersion: chartVersion,
    chartDependencies: [],
  };

  generateHelmConstruct(typegen, def);

  code.line(typegen.render());

  code.closeFile(filename);
  await code.save(path.join(filePath));

  // await convertToOtherLanguages(filename, filePath);
}
